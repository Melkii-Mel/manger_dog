use std::fmt;
use thiserror::Error;

pub type BuilderResult = Result<String, BuilderError>;
#[derive(Debug, Error)]
pub enum BuilderError {
    #[error("Format error: {0}")]
    Fmt(#[from] fmt::Error),
    #[error("Foreign key is not defined in the map: {0}. Consider ")]
    Fkey(String),
    #[error("Foreign key map is not defined in the builder, but you are trying to select items by a foreign key. Consider providing fkey_map with all the necessary `fkey => validation path` associations"
    )]
    FkeyMap(String),
}

#[derive(Debug, Error)]
pub enum DbResultError {
    #[error("An error occurred when calling take() on a Response: {0}")]
    TakeError(#[from] surrealdb::Error),
}

/// A builder for queries that perform transactions requiring ownership validation.
///
/// Any query generated by `QueryBuilder` requires the `$user_id` to be bound and
/// will only succeed if `$user_id` matches all specified ownership paths.
pub struct QueryBuilder {
    pub table_name: &'static str,
    pub paths: &'static [&'static str],
    pub fkey_path_map: Option<&'static phf::Map<&'static str, &'static str>>,
}
impl QueryBuilder {
    /// To bind:
    /// - $value
    pub fn insert(&self) -> BuilderResult {
        wrap_in_transaction(build_validation_segment(
            "$value",
            self.paths,
            format!("INSERT INTO {} $value RETURN ID;", self.table_name),
        ))
    }

    /// To bind:
    /// - $id
    pub fn select(&self) -> BuilderResult {
        wrap_in_transaction(build_validation_segment(
            "$id",
            &self.paths[..1],
            "SELECT * FROM $id".to_string(),
        ))
    }

    /// To bind:
    ///
    pub fn select_all(&self) -> BuilderResult {
        wrap_in_transaction(format!(
            "SELECT * FROM {} WHERE {} = $user_id",
            self.table_name, self.paths[0]
        ))
    }

    /// To bind:
    /// $fkey
    pub fn select_all_by_fkey(&self, fkey: &str) -> BuilderResult {
        wrap_in_transaction(build_validation_segment(
            "$fkey",
            std::slice::from_ref(
                self.fkey_path_map
                    .ok_or(BuilderError::FkeyMap(fkey.to_string()))?
                    .get(fkey)
                    .ok_or(BuilderError::Fkey(fkey.to_string()))?,
            ),
            format!(
                "SELECT * FROM {} WHERE {} = $fkey",
                self.table_name, self.paths[0]
            ),
        ))
    }

    /// To bind:
    /// - $id
    pub fn delete(&self) -> BuilderResult {
        wrap_in_transaction(build_validation_segment(
            "$id",
            &self.paths[..1],
            "DELETE $id".to_string(),
        ))
    }

    /// To bind:
    /// - $id
    /// - $value
    pub fn update(&self) -> BuilderResult {
        wrap_in_transaction(build_validation_segment(
            "$id",
            &self.paths[..1],
            format!(
                "{};{};",
                "UPDATE $id CONTENT $value;",
                build_validation_segment("id", &self.paths, "RETURN NONE;".to_string()),
            ),
        ))
    }
}

/// To bind:
/// - $user_id
fn wrap_in_transaction(action: String) -> BuilderResult {
    Ok(format!(
        "BEGIN TRANSACTION; {}; COMMIT TRANSACTION;",
        action
    ))
}

/// To bind:
/// - $user_id
fn build_validation_segment(key_name: &str, paths: &[&'static str], else_branch: String) -> String {
    let mut result = else_branch;
    for path in paths.iter().rev() {
        result = format!(
            "IF({}.{} != $user_id){{THROW 'AUTH_ERR'}}ELSE{{{}}};",
            key_name, path, result
        );
    }
    result
}
